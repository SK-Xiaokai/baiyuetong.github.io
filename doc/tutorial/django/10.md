---
title: 数据库表的关联
---


后端系统开发中， 数据库设计是重中之重。 

而关系型数据库，设计的一个难点就是各种表之间的关联关系。
  
常见的几种关联关系是：  多对一，一对一，多对多



## 多对一

表之间一对多的关系，就是 **外键**

比如，我们的  BYSMS 系统中， 现在已经定义了客户这张表对应的Model。如下所示

```py
class Customer(models.Model):
    # 客户名称
    name = models.CharField(max_length=200)

    # 联系电话
    phonenumber = models.CharField(max_length=200)

    # 地址
    address = models.CharField(max_length=200)
```
<br><br>
我们还需要定义 药品 这张表，包括药品名称、编号和描述，这个也很简单，添加如下的类定义

```py
class Medicine(models.Model):
    # 药品名
    name = models.CharField(max_length=200)
    # 药品编号
    sn = models.CharField(max_length=200)
    # 描述
    desc = models.CharField(max_length=200)
```


<br><br>
接下来我们要定义订单这张表，这个订单表 包括 创建日期、客户、药品、数量。

其中：

 客户字段对应的客户只能是 客户表中的某个客户记录
 
 所以可以说：
 
 一条订单记录里面的客户 只能对应一个客户记录

 而 **多条** 订单记录里面的客户可以对应 同一个客户记录

这就是一对多（或者说 多对一）的关系，可以用如下图片表示

  ![image](https://user-images.githubusercontent.com/36462795/39673183-096cec8e-516a-11e8-8089-1abf31e74825.png)



<br><br>

像这种一对多的关系，数据库中是用 **外键** 来表示的。

如果一个表中 的 某个字段是外键，就是说这个字段指向另外一个表的主键。
外键字段的值，只能是它指向的那个表的主键某个记录的值。

Django定义Model的时候，如果没有指定一个字段为主键，Django 会为该Model对应的数据库表自动生成一个id字段，作为主键。

比如，我们这里，客户、药品表均没有主键，但是在migrate之后，查看数据库记录就可以发现有一个id字段，且该字段是 主键 (primary key)

![image](https://user-images.githubusercontent.com/36462795/39673295-0861f7a6-516c-11e8-9b21-17a1e96f5640.png)

<br>

现在我们要定义 订单 表的时候， 

客户字段就应该是一个外键，对应客户表的主键，也就是id字段

Django中定义外键 的方法就是 在Model类的属性字段使用 ForeignKey对象，如下所示

```py
import datatime
class Order(models.Model):
    # 订单名
    name = models.CharField(max_length=200,null=True,blank=True)

    # 创建日期
    create_date = models.DateTimeField(default=datetime.datetime.now)

    # 客户
    customer = models.ForeignKey(Customer,on_delete=models.PROTECT)
```

大家可以发现， customer 字段 是外键， 指向 Customer 和 Medicine 类。 

其中另外一个参数 **on_delete** 指定了 当我们想 删除 外键指向的主键 记录时， 系统的行为。

比如 我们要删除客户记录， 那么 订单表中 对应这个客户的订单记录 该如何处理呢？

on_delete 不同取值对应不同的做法，常见的做法如下

- CASCADE

  删除主键记录和 相应的外键表记录。 

  比如，我们要删除客户记录，在删除了客户记录同时，也删除订单表中所有这个客户的订单记录

  
- PROTECT

  禁止删除记录。 

  比如，我们要删除客户记录时，如果订单表中有该客户的订单记录。Django系统 抛出ProtectedError类型的异常，当然也就禁止删除 客户记录和相关的订单记录了。

  除非我们将订单表中所有该客户的订单记录都先删除掉，才能删除该客户记录。


- SET_NULL

  删除主键记录，并且将外键记录中外键字段的值置为null。 当然前提是外键字段要设置为值允许是null。

  比如，我们要删除客户记录时，在删除了客户记录同时，将订单表里面的 customer字段值置为 null。 但是上面我们并没有设置 customer 字段有   ```null=True``` 的参数设置，所以，是不能取值为 SET_NULL的。


<br><br>

## 一对一

外键是多对一的关系。

有的时候，表之间是**一对一**的关系。

比如，某个学校的学生 表  和学生的地址表，就形成一对一的关系，即 一条主键所在表的记录 只能对应一条 外键所在表的记录。

Django 中 用  OneToOneField 类型 实现 一对一的关系，如下


```py
class Student(models.Model):
    # 姓名
    name = models.CharField(max_length=200)
    # 班级
    classname = models.CharField(max_length=200)
    # 描述
    desc = models.CharField(max_length=200)


class ContactAddress(models.Model):
    # 一对一 对应学生 
    student = models.OneToOneField(Student, on_delete=models.PROTECT)
    # 家庭
    homeaddress = models.CharField(max_length=200)
    # 电话号码
    phone = models.CharField(max_length=200)
```



其实一对一的关系，在数据库中就是， 定义为外键的同时 加上  ```unique=True``` 约束，表示在此表中，所有记录的该字段 取值必须唯一，不能重复。






<br><br>

## 多对多


数据库表还有一种 **多对多** 的关系。

在我们的 BYSMS系统中，  一个订单可以对应 药品表里面的多种药品， 那么订单表 和 药品表 之间就形成了多对多的关系。
  
在django中，  是通过 ManyToManyField 类型 表示 多对多的关系的。

如下所示：

```py
import datatime
class Order(models.Model):
    # 订单名
    name = models.CharField(max_length=200,null=True,blank=True)

    # 创建日期
    create_date = models.DateTimeField(default=datetime.datetime.now)

    # 客户
    customer = models.ForeignKey(Customer,on_delete=models.PROTECT)

    # 订单购买的药品，和药品表是多对多 的关系
    medicines = models.ManyToManyField(Medicine, through='OrderMedicine')


class OrderMedicine(models.Model):
    order = models.ForeignKey(Order, on_delete=models.PROTECT)
    medicine = models.ForeignKey(Medicine, on_delete=models.PROTECT)

    # 订单中药品的数量
    amount = models.PositiveIntegerField()    
```

<br>

像这样 

```py
medicines = models.ManyToManyField(Medicine, through='OrderMedicine')
```

指定Order表和 Medicine 表 的多对多关系， 其实Order表中并不会产生一个 叫 medicines 的字段。 

Order表和 Medicine 表 的多对多关系 是 **通过另外一张表**， 也就是 through 参数 指定的 OrderMedicine 表 来确定的。


migration的时候，Django会自动产生的一张新表 （这里就是 common_ordermedicine）来 实现 order 表 和 medicine 表之间的多对多的关系。

如下：

![image](https://user-images.githubusercontent.com/36462795/45473201-077ece00-b769-11e8-981a-144862a9fbff.png)

可以发现这张表中有 order_id 和 medicine_id 两个字段。 

比如一个order表的订单id 为 1， 如果该订单中对应的药品的id 为 3，4，5。 那么就会有类似这样的这样3条记录在 common_order_medicine 表中。

| order_id        | medicine_id           | 
| :-------------: |:-------------:|
| 1      | 3    |
| 1      | 4    | 
| 1      | 5    | 



<br><br>



## 实现代码

现在我们要实现 药品和订单 管理的服务端代码了。

<br>

### 药品管理 

其中药品管理部分比较简单， 和前面的客户管理部分基本类似。

我们在 mgr 目录下面新建 medicine.py 来实现 当客户端发起 列出药品、添加药品、修改药品和删除药品 时， 服务端的 处理代码。

如下所示

```py
from django.http import JsonResponse

# 导入 Medicine 对象定义
from  common.models import  Medicine

import json

def dispatcher(request):
    # 将请求参数统一放入request 的 params 属性中，方便后续处理
    if request.method == 'GET':
        request.params = request.GET
        return  listmedicines(request)

    elif request.method in ['POST','PUT','DELETE']:
        request.params = json.loads(request.body)
        # 根据不同的action分派给不同的函数进行处理
        if request.params['action'] == 'add_medicine':
            return addmedicine(request)
        if request.params['action'] == 'modify_medicine':
            return modifymedicine(request)
        elif request.params['action'] == 'del_medicine':
            return deletemedicine(request)

    else:
        return JsonResponse({'ret': 1, 'msg': '不支持该类型http请求'})

def listmedicines(request):
    # 返回一个 QuerySet 对象 ，包含所有的表记录
    qs = Medicine.objects.values()

    # 将 QuerySet 对象 转化为 list 类型
    # 否则不能 被 转化为 JSON 字符串
    retlist = list(qs)

    return JsonResponse({'ret': 0, 'retlist': retlist})


def addmedicine(request):

    info    = request.params['data']

    # 从请求消息中 获取要添加客户的信息
    # 并且插入到数据库中
    medicine = Medicine.objects.create(name=info['name'] ,
                            sn=info['sn'] ,
                            desc=info['desc'])


    return JsonResponse({'ret': 0, 'id':medicine.id})


def modifymedicine(request):

    # 从请求消息中 获取修改客户的信息
    # 找到该客户，并且进行修改操作

    medicineid = request.params['id']
    newdata    = request.params['newdata']

    try:
        # 根据 id 从数据库中找到相应的客户记录
        medicine = Medicine.objects.get(id=medicineid)
    except Medicine.DoesNotExist:
        return  {
                'ret': 1,
                'msg': f'id 为`{medicineid}`的药品不存在'
        }


    if 'name' in  newdata:
        medicine.name = newdata['name']
    if 'sn' in  newdata:
        medicine.sn = newdata['sn']
    if 'desc' in  newdata:
        medicine.desc = newdata['desc']

    # 注意，一定要执行save才能将修改信息保存到数据库
    medicine.save()

    return JsonResponse({'ret': 0})



def deletemedicine(request):

    medicineid = request.params['id']

    try:
        # 根据 id 从数据库中找到相应的药品记录
        medicine = Medicine.objects.get(id=medicineid)
    except Medicine.DoesNotExist:
        return  {
                'ret': 1,
                'msg': f'id 为`{medicineid}`的客户不存在'
        }

    # delete 方法就将该记录从数据库中删除了
    medicine.delete()

    return JsonResponse({'ret': 0})
```

<br><br>

### 订单管理

同样，我们在 mgr 目录下面新建 order.py 来实现 当客户端发起 列出药品、添加药品 时， 服务端的 处理代码。

代码如下

```py
from django.http import JsonResponse
from django.db.models import F
from django.db import IntegrityError, transaction

# 导入 Order 对象定义
from  common.models import  Order,OrderMedicine

import json

def dispatcher(request):
    # 将请求参数统一放入request 的 params 属性中，方便后续处理
    if request.method == 'GET':
        request.params = request.GET
        return  listorders(request)

    elif request.method in ['POST','PUT','DELETE']:
        request.params = json.loads(request.body)
        # 根据不同的action分派给不同的函数进行处理
        if request.params['action'] == 'add_order':
            return addorder(request)
        if request.params['action'] == 'modify_order':
            return modifyorder(request)
        elif request.params['action'] == 'del_order':
            return deleteorder(request)

    else:
        return JsonResponse({'ret': 1, 'msg': '不支持该类型http请求'})

def listorders(request):
    # 返回一个 QuerySet 对象 ，包含所有的表记录
    qs = Order.objects.select_related('customer').prefetch_related('medicines')\
            .annotate(
                customer_name=F('customer__name'),medicines_name=F('medicines__name')
            )\
            .values(
                'id','name','create_date','customer_name','medicines_name'
            )

    # 将 QuerySet 对象 转化为 list 类型
    # 否则不能 被 转化为 JSON 字符串
    retlist = list(qs)

    # 可能有 ID相同，药品不同的订单记录， 需要合并
    newlist = []
    id2order = {}
    for one in retlist:
        orderid = one['id']         
        if orderid not in id2order:
            newlist.append(one)
            id2order[orderid] = one
        else:
            id2order[orderid]['medicines_name'] += ' | ' + one['medicines_name']

    

    return JsonResponse({'ret': 0, 'retlist': newlist})


def addorder(request):

    info    = request.params['data']

    # 从请求消息中 获取要添加订单的信息
    # 并且插入到数据库中

    
    with transaction.atomic():
        new_order = Order.objects.create(name=info['name'] ,
                                         customer_id=info['customerid'])

        batch = [OrderMedicine(order_id=new_order.id,medicine_id=mid,amount=1)  for mid in info['medicineids']]
        OrderMedicine.objects.bulk_create(batch)


    return JsonResponse({'ret': 0,'id':new_order.id})

```


<br><br>

先来看 **列出订单** 的处理函数 listorders，可能大家最不容易理解的就是下面这段代码

```py
qs = Order.objects.select_related('customer').prefetch_related('medicines')\
        .annotate(
            customer_name=F('customer__name'),
            medicines_name=F('medicines__name')
        )\
        .values(
            'id','name','create_date','customer_name','medicines_name'
        )
```

其中的 select_related 和 prefetch_related 是什么意思呢？

我们获取订单信息， 不仅仅需要获取 orders 这张表中记录， 还需要获取每条记录 其 关联的 Custormer 客户表 和 Medicine 药品表信息。

select_related 方法就是告诉 Django 获取 订单表记录同时，获取指定 外键字段 customer 关联表 Customer 中对应记录的信息。

prefetch_related 方法就是告诉 Django 获取 订单表记录同时，获取 OrderMedicine 关联表涉及到的 Medicine 中对应记录的信息。

获取哪些字段呢？

通过 values 方法的参数指定， 这里就是

```py
'id','name','create_date','customer__name','medicines__name'
```

注意，其他表中的字段名， 要加上 关联字段名 作为前缀 ，后面加上两个下划线，就是这样 
```py
'customer__name','medicines__name'
```


<br>
那么 下面这个 annotate 方法又是干什么的呢？

```py
.annotate(
            customer_name=F('customer__name'),
            medicines_name=F('medicines__name')
        )
```

如果，我们嫌  customer__name 这样的命名很难看， 

可以使用 annotate 方法 进行重新命名， 这里就是把 customer__name 里面的两个下划线 改为一个下划线了，变成这样 customer_name。


<br>

由于 订单记录 和 药品记录是多对多的关系， 一个订单可能包含多个药品，这样查询出来的结果，可能有一条订单会有多条记录 分别对应不同的 药品。

所以，下面的代码就是进行 合并

```py
 # 可能有 ID相同，药品不同的订单记录， 需要合并
    newlist = []
    id2order = {}
    for one in retlist:
        orderid = one['id']         
        if orderid not in id2order:
            newlist.append(one)
            id2order[orderid] = one
        else:
            id2order[orderid]['medicines_name'] += ' | ' + one['medicines_name']
```

<br>
----------
<br>

在来看 **添加订单** 的处理函数 addorder，如下所示

```py
def addorder(request):

    info    = request.params['data']

    # 从请求消息中 获取要添加订单的信息
    # 并且插入到数据库中

    
    with transaction.atomic():
        new_order = Order.objects.create(name=info['name'] ,
                                         customer_id=info['customerid'])

        batch = [OrderMedicine(order_id=new_order.id,medicine_id=mid,amount=1)  for mid in info['medicineids']]
        OrderMedicine.objects.bulk_create(batch)


    return JsonResponse({'ret': 0,'id':new_order.id})
```

我们添加一条订单记录，需要在2张表（Order 和 OrderMedicine ）中添加记录， 所以这里我们使用了  ```with transaction.atomic()```  

这样， 其内部的对数据库的操作，就都是在一个事务中进行了。

如果其中有任何一步数据操作失败了， 前面的操作都不会生效。 方式出现 前面的 订单表记录插入成功， 而后面的 订单药品 记录插入失败而导致的数据不一致现象。



<br><br>

实现了请求处理的模块后，我们可以在 mgr\urls.py  里面加上 对 orders 请求处理的路由

```py
from django.conf.urls import url
from mgr.sign_in_out import signin, signout
from mgr import customer,medicine,order

urlpatterns = [

    url('signin', signin),
    url('signout', signout),

    url('customers', customer.dispatcher),
    url('medicines', medicine.dispatcher),
    url('orders', order.dispatcher),

]
```

然后，就可以进行测试了。


如果前端开发工程师也完成了他们的前端开发，就可以进行集成测试了。



<br><br>

目前为止，我们系统的完整代码，[点击这里下载](https://github.com/baiyueheiyu/fileshare/raw/master/webdev/bysms_5.zip)

<br><br>

[上一页](/doc/tutorial/django/09/){: .btn .btn--primary .align-left }
[下一页](/doc/tutorial/django/11/){: .btn .btn--primary .align-right }






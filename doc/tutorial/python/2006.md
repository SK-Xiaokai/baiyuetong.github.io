---
title: 正则表达式
---


## 有什么用？

大家看一个例子。


一个文本文件里面存储了 一些市场职位信息，格式如下所示

```
Python3 高级开发工程师 上海互教教育科技有限公司上海-浦东新区2万/月02-18满员
测试开发工程师（C++/python） 上海墨鹍数码科技有限公司上海-浦东新区2.5万/每月02-18未满员
Python3 开发工程师 上海德拓信息技术股份有限公司上海-徐汇区1.3万/每月02-18剩余11人
测试开发工程师（Python） 赫里普（上海）信息科技有限公司上海-浦东新区1.1万/每月02-18剩余5人
Python高级开发工程师 上海行动教育科技股份有限公司上海-闵行区2.8万/月02-18剩余255人
python开发工程师 上海优似腾软件开发有限公司上海-浦东新区2.5万/每月02-18满员
```

现在，我们需要写一个程序，从这些文本里面抓取 所有职位的薪资。

就是要获取这样的结果

```py
2
2.5
1.3
1.1
2.8
2.5
```

怎么做？

大家先自己思考一下。


<br><br>

这是典型的字符串处理。

分析这里面的规律，可以发现，薪资的数字 后面 都有关键字  ```万/月``` 或者  ```万/每月``` 

根据我们学过的知识，我们不难写出下面的代码

```py
content = '''
Python3 高级开发工程师 上海互教教育科技有限公司上海-浦东新区2万/月02-18满员
测试开发工程师（C++/python） 上海墨鹍数码科技有限公司上海-浦东新区2.5万/每月02-18未满员
Python3 开发工程师 上海德拓信息技术股份有限公司上海-徐汇区1.3万/每月02-18剩余11人
测试开发工程师（Python） 赫里普（上海）信息科技有限公司上海-浦东新区1.1万/每月02-18剩余5人
Python高级开发工程师 上海行动教育科技股份有限公司上海-闵行区2.8万/月02-18剩余255人
python开发工程师 上海优似腾软件开发有限公司上海-浦东新区2.5万/每月02-18满员
'''

# 将文本内容按行放入列表
lines = content.splitlines()
for line in lines:
    # 查找'万/月' 在 字符串中什么地方
    pos2 = line.find('万/月')
    if pos2 < 0:
        # 查找'万/每月' 在 字符串中什么地方
        pos2 = line.find('万/每月')
        # 都找不到
        if pos2 < 0: 
            continue

    # 执行到这里，说明可以找到薪资关键字
    # 接下来分析 薪资 数字的起始位置
    # 方法是 找到 pos2 前面薪资数字开始的位置
    idx = pos2-1

    # 只要是数字或者小数点，就继续往前面找
    while line[idx].isdigit() or line[idx]=='.':
        idx -= 1

    # 现在 idx 指向 薪资数字前面的那个字，
    # 所以薪资开始的 索引 就是 idx+1
    pos1 = idx + 1

    print(line[pos1:pos2])
```

运行一下，发现完全可以。

在你高兴完之后，我们再看看写的代码。

怎么样？

太麻烦了，是不是。

为了从每行获取薪资对应的数字，我们 可是 写了不少行代码。 

这种  ```从字符串中搜索出某种特征的子串```   有没有更简单的方法呢？

解决方案就是我们今天要介绍的  ```正则表达式``` 。

<br>
如果我们使用正则表达式，代码可以这样

```py
content = '''
Python3 高级开发工程师 上海互教教育科技有限公司上海-浦东新区2万/月02-18满员
测试开发工程师（C++/python） 上海墨鹍数码科技有限公司上海-浦东新区2.5万/每月02-18未满员
Python3 开发工程师 上海德拓信息技术股份有限公司上海-徐汇区1.3万/每月02-18剩余11人
测试开发工程师（Python） 赫里普（上海）信息科技有限公司上海-浦东新区1.1万/每月02-18剩余5人
Python高级开发工程师 上海行动教育科技股份有限公司上海-闵行区2.8万/月02-18剩余255人
python开发工程师 上海优似腾软件开发有限公司上海-浦东新区2.5万/每月02-18满员
'''

import re
p = re.compile(r'([\d.]*)万/每{0,1}月')
for one in  p.findall(content):
    print(one)
```

运行一下看看，结果是一样的。

但是代码却简单多了。

简单解释一下： 

正则表达式，是一种语法，用来描述你想搜索的字符串的特征。

下面这行代码指定了一个正则表达式

```py
p = re.compile(r'([\d.]*)万/每{0,1}月')
```

compile函数的参数，就是正则表达式字符串，上面的例子里面指定了 搜索子串的特征 是  ```([\d.]*)万/每{0,1}月``` 

为什么这么写？ 我们后面再介绍。

这个函数返回一个compile对象。 

compile对象的 findall 方法返回所有匹配的子串，放在一个列表中。

<br>

从 上面的 例子可以看出， 用正则表达式关键的地方在于，如何写出正确的表达式语法。

正则表达式非常强大，语法非常复杂，如果你英文阅读能力还可以，那太好了，[点击这里，参考Python官方文档里面的描述](https://docs.python.org/3/howto/regex.html) 。具体的使用细节包括语法都在里面。



## 在线验证

怎么验证你写的表达式 是否能正确匹配到要搜索的字符串呢？

大家可以访问这个网址： https://regex101.com/

按照下面的图片，验证你的表达式是否正确。

![image](https://user-images.githubusercontent.com/36462795/52932905-5ff76e80-338c-11e9-960a-23643b082af8.png)

<br>

## 常见语法

我们这里，介绍一些常见的语法


<br>

写在正则表达式里面的大部分的字符都是表示： 直接匹配它们。 

比如 你下面的文本中，如果你要找所有的 test， 正则表达式就非常简单，直接输入 test 即可。 

如下所示：

![image](https://user-images.githubusercontent.com/36462795/52953502-9e0f8500-33c2-11e9-9371-4801227c1f98.png)


汉字也是一样，要寻找汉字，直接写在正则表达式里面就可以了。

----

但是有些特殊的字符，术语叫 metacharacters（元字符）。

它们出现在正则表达式字符串中，不是表示直接匹配他们， 而是表达一些特别的含义。

这些特殊的元字符包括下面这些：

```
. * + ? \ [ ] ^ $ { } | ( )
```

我们分别介绍一下它们的含义：

<br>

### 点 ： .

 ```.```  表示要匹配除了 换行符 之外的任何 ```单个``` 字符。 

比如，你要从下面的文本中，选择出所有的颜色。

```
苹果是绿色的
橙子是橙色的
香蕉是黄色的
乌鸦是黑色的
```

也就是要找到所有   以 ```色``` 结尾，并且包括前面的一个字符的 词语。

就可以这样写正则表达式  ```.色``` 。

其中 点 代表了任意的一个字符， 注意是一个字符。 

```.色``` 合起来就表示 要找 任意一个字符 后面是 色 这个字， 合起来两个字的 字符串

验证一下，如下图所示

![image](https://user-images.githubusercontent.com/36462795/52954564-81288100-33c5-11e9-84a7-27b990bea671.png)



<br>

只要表达式正确，就可以写在Python代码中，如下所示

```py
content = '''苹果是绿色的
橙子是橙色的
香蕉是黄色的
乌鸦是黑色的'''

import re
p = re.compile(r'.色')
for one in  p.findall(content):
    print(one)
```

运行结果如下

```
绿色
橙色
黄色
黑色
```

<br>


更直观的解释，请看下面的视频


### 星号 ： *


 ```*```  表示匹配前面的子表达式任意次，包括0次。 

比如，你要从下面的文本中，选择每行逗号后面的字符串内容，包括逗号本身。注意，这里的逗号是中文的逗号。

```
苹果，是绿色的
橙子，是橙色的
香蕉，是黄色的
乌鸦，是黑色的
猴子，
```


就可以这样写正则表达式  ```，.*``` 。

* 紧跟在 . 后面， 表示 任意字符可以出现任意次， 所以整个表达式的意思就是在逗号后面的 所有字符，包括逗号


验证一下，如下图所示

![image](https://user-images.githubusercontent.com/36462795/52955690-4411be00-33c8-11e9-9ac2-d88b3b84f8aa.png)

特别是最后一行，猴子逗号后面没有其它字符了，但是*表示可以匹配0次， 所以表达式也是成立的。



<br>

只要表达式正确，就可以写在Python代码中，如下所示

```py
content = '''苹果，是绿色的
橙子，是橙色的
香蕉，是黄色的
乌鸦，是黑色的
猴子，'''

import re
p = re.compile(r'，.*')
for one in  p.findall(content):
    print(one)
```

运行结果如下

```
，是绿色的
，是橙色的
，是黄色的
，是黑色的
，
```

<br>

注意， .* 在正则表达式中非常常见，表示匹配任意字符任意次数。

当然这个 * 前面不是非得是 点 ，也可以是其它字符，比如

![image](https://user-images.githubusercontent.com/36462795/52957135-f5662300-33cb-11e9-8036-27b765506ee4.png)

<br>

更直观的解释，请看下面的视频



### 加号 ： +


 ```+```  表示匹配前面的子表达式一次或多次，不包括0次。 

比如，还是上面的例子，你要从文本中，选择每行逗号后面的字符串内容，包括逗号本身。

但是 添加一个条件， 如果逗号后面 没有内容，就不要选择了。

这样，下面的文本中，最后一行就没有匹配的了。

```
苹果，是绿色的
橙子，是橙色的
香蕉，是黄色的
乌鸦，是黑色的
猴子，
```


就可以这样写正则表达式  ```，.+``` 。


验证一下，如下图所示

![image](https://user-images.githubusercontent.com/36462795/52956085-504a4b00-33c9-11e9-86af-66b4d4f9a1f1.png)


最后一行，猴子逗号后面没有其它字符了，+表示至少匹配1次， 所以最后一行没有子串选中。


更直观的解释，请看下面的视频







### 问号 ： ?


 ```?```  表示匹配前面的子表达式0次或1次。 

比如，还是上面的例子，你要从文本中，选择每行逗号后面的1个字符，也包括逗号本身。


```
苹果，绿色的
橙子，橙色的
香蕉，黄色的
乌鸦，黑色的
猴子，
```


就可以这样写正则表达式  ```，.?``` 。


验证一下，如下图所示

![image](https://user-images.githubusercontent.com/36462795/52956624-b1bee980-33ca-11e9-99eb-fbf45bb41ac3.png)


最后一行，猴子逗号后面没有其它字符了，但是?表示匹配1次或0次， 所以最后一行也选中了一个逗号字符。


更直观的解释，请看下面的视频



### 反斜杠 ： \


 ```\```  在正则表达式中有多种用途。  

#### 对元字符的普通使用


比如，我们要在下面的文本中搜索 所有点前面的字符串，也包含点本身


```
苹果.是绿色的
橙子.是橙色的
香蕉.是黄色的
```


如果，我们这样写正则表达式  ```.*.``` ， 聪明的你肯定发现不对劲。

因为 点  是一个 元字符， 直接出现在正则表达式中，表示匹配任意的单个字符， 不能表示 . 这个字符本身的意思了。

怎么办呢？

如果我们要搜索的内容本身就包含元字符，就可以使用 反斜杠进行转义。

这里我们就应用使用这样的表达式： ```.*\.``` 

示例，Python程序如下

```py
content = '''苹果.是绿色的
橙子.是橙色的
香蕉.是黄色的'''

import re
p = re.compile(r'.*\.')
for one in  p.findall(content):
    print(one)
```

运行结果如下

```
苹果.
橙子.
香蕉.
```



####  组合特殊含义

反斜杠后面接一些字符，表示匹配一种类型的任意一个字符。

比如 


\d
Matches any decimal digit; this is equivalent to the class [0-9].
\D
Matches any non-digit character; this is equivalent to the class [^0-9].
\s
Matches any whitespace character; this is equivalent to the class [ \t\n\r\f\v].
\S
Matches any non-whitespace character; this is equivalent to the class [^ \t\n\r\f\v].
\w
Matches any alphanumeric character; this is equivalent to the class [a-zA-Z0-9_].
\W
Matches any non-alphanumeric character; this is equivalent to the class [^a-zA-Z0-9_].






更直观的解释，请看下面的视频

{% include sharepost.html %}





### 方括号 ： []



### 起始位置 ： ^


 ```^```  表示匹配文本的起始位置。  

如果是 ```多行模式``` ，表示匹配文本每行的开头位置。

比如，你要从下面的文本中，选择每行逗号前面的字符串，也包括逗号本身。


```
苹果，苹果是绿色的
橙子，橙子是橙色的
香蕉，香蕉是黄色的
```


就可以这样写正则表达式  ```^.*，``` 。

示例，Python程序如下

```py
content = '''苹果，苹果是绿色的
橙子，橙子是橙色的
香蕉，香蕉是黄色的'''

import re
p = re.compile(r'^.*，', re.MULTILINE)
for one in  p.findall(content):
    print(one)
```

注意，compile 的第二个参数 re.MULTILINE ，指明了使用多行模式，

运行结果如下

```
苹果，
橙子，
香蕉，
```

如果，去掉 compile 的第二个参数 re.MULTILINE， 运行结果如下

```
苹果，
```

就只有第一行了，因为非多行模式下，^ 只会匹配整个待搜索文本的开头位置。



如果在方括号中使用， 表示不接受方括号里面的字符集合。 

比如

```py
content = 'a1b2c3d4e5'

import re
p = re.compile(r'[^\d]' )
for one in  p.findall(content):
    print(one)
```

 ```[^\d]```  表示，选择非数字的字符

输出结果为：

```py
a
b
c
d
e
```

更直观的解释，请看下面的视频

{% include sharepost.html %}